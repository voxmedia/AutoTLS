{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TLS Tool","text":"<p>Welcome to the TLS Tool documentation site!</p> <p>TLS Tool is a lightweight, production-tested service for automating:</p> <ul> <li>Certificate issuance via ACME (Let's Encrypt and others)</li> <li>Safe renewal &amp; rotation</li> <li>Distribution to DNS/CDN/secrets providers</li> </ul>"},{"location":"components/certificates/","title":"Certificates Reference","text":""},{"location":"components/certificates/#tlstool.certificates","title":"tlstool.certificates","text":""},{"location":"components/certificates/#tlstool.certificates-classes","title":"Classes","text":""},{"location":"components/certificates/#tlstool.certificates.CertificateManager","title":"CertificateManager","text":"Source code in <code>tlstool/certificates.py</code> <pre><code>class CertificateManager:\n\n    def __init__(self, dns_plugin: DNSBase, secrets_plugin: SecretsBase):\n        \"\"\"Initialize the certificate manager with DNS and secrets plugins.\n\n        Loads Let\u2019s Encrypt configuration from settings and stores the provided DNS\n        and secrets plugin instances for use throughout the ACME workflow.\n\n        Args:\n            dns_plugin (DNSBase): DNS management plugin used to create, update, and\n                verify challenge records.\n            secrets_plugin (SecretsBase): Secrets management plugin used to retrieve\n                the ACME account key and store certificate material (PEMs).\n\n        Returns:\n            None\n        \"\"\"\n        self.le_directory_url = settings.LE_DIRECTORY_URL\n        self.le_account_key_secret_name = settings.LE_ACCOUNT_KEY_SECRET_NAME\n        self.le_account_key_secret = settings.LE_ACCOUNT_KEY_SECRET\n        self.dns = dns_plugin\n        self.secrets = secrets_plugin\n\n    def request_cert(self, domain: str, zone_id: str):\n        \"\"\"Request and provision a certificate for a single domain via ACME (LE).\n\n        Orchestrates the full certificate request flow:\n        creates an ACME order, prepares DNS-01 challenges, updates DNS records,\n        finalizes the order to obtain the full-chain certificate,\n        stores certificate materials in the secrets backend,\n        and, if applicable, restores any prior CNAME record.\n\n        Args:\n            domain (str): Fully qualified domain name to issue/renew a certificate for.\n            zone_id (str): Route53 (or provider) hosted zone identifier for the domain.\n\n        Returns:\n            list[dict] | str: On success, a list of objects describing stored\n                certificate materials (e.g., ARNs). On failure, a string error\n                message (e.g., when DNS update fails or ACME finalization returns\n                an error).\n\n        Notes:\n            - Updates DNS records for the ACME DNS-01 challenge and waits for\n              propagation.\n            - Stores the private key, CSR, and full chain in the secrets backend.\n        \"\"\"\n        logger.info(f\"Requesting certificate for {domain}\")\n\n        try:\n            client_acme, order_object, pkey_pem, csr_pem = self._begin_acme_order(domain)\n            dns_data = self._prepare_dns_challenges(client_acme, order_object)\n            ready_to_validate = self._update_dns([i[2] for i in dns_data], domain, zone_id)\n\n            if ready_to_validate is not True:\n                return f\"Error: DNS update failed for {domain}\"\n\n            fullchain_pem = self._finalize_acme_order(client_acme, order_object, dns_data, domain)\n            if isinstance(fullchain_pem, str) and fullchain_pem.startswith(\"Error\"):\n                return fullchain_pem\n\n            arns = self._store_cert_materials(domain, pkey_pem, csr_pem, fullchain_pem)\n            return arns\n\n        except Exception as e:\n            err = f\"Unexpected error requesting cert for {domain}: {e}\"\n            logger.exception(err)\n            return err\n\n    def _begin_acme_order(self, domain):\n        \"\"\"Initialize ACME client and begin a certificate order for a domain.\n\n        Loads the Let\u2019s Encrypt account key from the secrets backend, constructs the\n        ACME client, registers (only if an existing account is found), creates a new\n        private key and CSR for the domain, and opens a new order.\n\n        Args:\n            domain (str): Fully qualified domain name to include in the CSR (also\n                used to generate a wildcard SAN `*.{domain}`).\n\n        Returns:\n            tuple[acme.client.ClientV2, Any, bytes, bytes] | bool:\n                On success, a 4-tuple of:\n                - client_acme: Initialized ACME v2 client.\n                - order_object: The ACME order resource created for the CSR.\n                - pkey_pem: PEM-encoded RSA private key (bytes).\n                - csr_pem: PEM-encoded certificate signing request (bytes).\n                Returns `False` if the stored account key is not valid JSON.\n\n        Raises:\n            Exception: May propagate exceptions from ACME/HTTP or cryptography\n                libraries if network calls or cryptographic operations fail.\n        \"\"\"\n        account_secret = self.secrets.get_secret_value(self.le_account_key_secret_name)\n        try:\n            account_key = json.loads(account_secret.strip())\n        except json.decoder.JSONDecodeError:\n            logger.exception(f\"Lets Encrypt account key is not valid: {str(account_secret.strip())}\")\n            return False\n\n        user_key = josepy.JWKRSA.fields_from_json(account_key)\n        net = ClientNetwork(user_key)\n        directory = messages.Directory.from_json(net.get(self.le_directory_url).json())\n        client_acme = ClientV2(directory, net)\n        reg = messages.NewRegistration(key=user_key.public_key(), only_return_existing=True)\n        response = client_acme._post(directory['newAccount'], reg)\n        regr = client_acme._regr_from_response(response)\n        client_acme.query_registration(regr)\n\n        # Create domain private key and CSR\n        pkey_pem, csr_pem = self._new_csr(domain)\n        order_object = client_acme.new_order(csr_pem)\n        return client_acme, order_object, pkey_pem, csr_pem\n\n    def _prepare_dns_challenges(self, client_acme, order_object):\n        \"\"\"Prepare ACME DNS-01 challenges for the current order.\n\n        Fetches the DNS-01 challenge objects from the ACME order and converts each\n        into a tuple of the challenge, its corresponding response object, and the\n        validation token needed for DNS TXT records.\n\n        Args:\n            client_acme: The initialized ACME v2 client.\n            order_object: The ACME order resource containing authorizations.\n\n        Returns:\n            list[list]: A list where each item is\n                `[challenge_body, response_object, validation_token]` for a DNS-01\n                challenge associated with the order.\n        \"\"\"\n        logger.info(\"Requesting DNS challenges\")\n        dns_challenge_objects = self._get_dns_challenge(order_object)\n\n        logger.info(\"Converting tokens\")\n        dns_data = []\n        for obj in dns_challenge_objects:\n            response, validation_token = obj.response_and_validation(client_acme.net.key)\n            dns_data.append([obj, response, validation_token])\n        return dns_data\n\n    def _finalize_acme_order(self, client_acme, order_object, dns_data, domain):\n        \"\"\"Finalize an ACME order by answering DNS-01 challenges and polling for completion.\n\n        Iterates through the prepared DNS-01 challenges, submits each answer to the\n        ACME server, and then polls the order until it is finalized or the timeout\n        is reached. On success, returns the full-chain certificate in PEM format.\n\n        Args:\n            client_acme: The initialized ACME v2 client used to answer challenges\n                and finalize the order.\n            order_object: The ACME order resource to be finalized.\n            dns_data (list[list]): Challenge tuples produced by `_prepare_dns_challenges`,\n                each in the form `[challenge_body, response_object, validation_token]`.\n            domain (str): The fully qualified domain name associated with the order,\n                used for logging and error messages.\n\n        Returns:\n            str: The PEM-encoded full-chain certificate on success, or a human-readable\n                error string on failure.\n\n        Notes:\n            - Uses a fixed timeout of 180 seconds for `poll_and_finalize`.\n            - ACME validation errors are logged with details; a generic error string\n              is returned in those cases.\n        \"\"\"\n        try:\n            logger.info('--------- authorizing')\n            for challb, response, _ in dns_data:\n                logger.info(f\"Trying answer challenge: {challb} {response}\")\n                challenge_resource = client_acme.answer_challenge(challb, response)\n                logger.info(f\"Resulting challenge resource: {challenge_resource}\")\n            timeout = datetime.datetime.now() + datetime.timedelta(seconds=180)\n            logger.info(\"Attempting acme finalize order to validate auth\")\n            finalized_order = client_acme.poll_and_finalize(order_object, timeout)\n            logger.info(\"LE Auth valid\")\n            return finalized_order.fullchain_pem\n        except errors.ValidationError as e:\n            logger.exception(f\"Validation error on {domain}: {e.failed_authzrs}\")\n            return f\"Error validating domain {domain}. See logs for details.\"\n        except Exception as e:\n            err = f\"Error: Answer challenge exception for {domain}: {e}\"\n            logger.exception(err)\n            return err\n\n    def _store_cert_materials(self, domain, pkey_pem, csr_pem, fullchain_pem):\n        \"\"\"Persist certificate materials to the secrets backend.\n\n        Packages the CSR, private key, and full-chain certificate into a list and\n        delegates storage to `_store_pems`. Returns the resulting identifiers (e.g.,\n        ARNs) on success or a string error message on failure.\n\n        Args:\n            domain (str): The fully qualified domain name the materials belong to.\n            pkey_pem (bytes | str): PEM-encoded private key.\n            csr_pem (bytes | str): PEM-encoded certificate signing request.\n            fullchain_pem (bytes | str): PEM-encoded full-chain certificate.\n\n        Returns:\n            list[dict] | str: A list of stored item identifiers on success, or a\n                string error message on failure.\n        \"\"\"\n        pem_list = [\n            {'key': 'csr', 'value': csr_pem},\n            {'key': 'private_key', 'value': pkey_pem},\n            {'key': 'fullchain', 'value': fullchain_pem}\n        ]\n        try:\n            arns = self._store_pems(domain, pem_list)\n            return arns\n        except Exception as e:\n            err = f\"Error storing certificate for {domain}: {e}\"\n            logger.exception(err)\n            return err\n\n    def _new_csr(self, domain, pkey_pem=None):\n        \"\"\"Create a new CSR (and key if needed) for the given domain.\n\n        Generates a new RSA private key when `pkey_pem` is not provided and builds a\n        CSR that includes both the apex domain and a wildcard SAN (`*.{domain}`).\n\n        Args:\n            domain (str): The fully qualified domain name to include in the CSR and\n                as the basis for the wildcard SAN.\n            pkey_pem (bytes | None): Optional PEM-encoded private key. If `None`, a\n                new 2048-bit RSA key is generated and returned.\n\n        Returns:\n            tuple[bytes, bytes]: A `(pkey_pem, csr_pem)` tuple containing the\n                PEM-encoded private key and the PEM-encoded CSR.\n        \"\"\"\n        if pkey_pem is None:\n            pkey = crypto.PKey()\n            pkey.generate_key(crypto.TYPE_RSA, 2048)\n            pkey_pem = crypto.dump_privatekey(FILETYPE_PEM, pkey)\n        csr_pem = crypto_util.make_csr(pkey_pem, [domain, \"*.\"+domain])\n        return pkey_pem, csr_pem\n\n    def _get_dns_challenge(self, order_object):\n        \"\"\"Extract DNS-01 challenges from the ACME order authorizations.\n\n        Iterates over the order\u2019s authorizations and collects all DNS-01 challenge\n        bodies offered by the CA. Logs an informational message when no DNS-01\n        challenges are present.\n\n        Args:\n            order_object: The ACME order resource whose authorizations will be\n                inspected for DNS-01 challenges.\n\n        Returns:\n            list: A list of challenge body objects for DNS-01; an empty list if none\n                are offered.\n        \"\"\"\n        # This object holds the offered challenges by server and status.\n        authz_list = order_object.authorizations\n        chall = []\n        for authz in authz_list:\n            for i in authz.body.challenges:\n                if isinstance(i.chall, challenges.DNS01):\n                    chall.append(i)\n        if not chall:\n            logger.info(\"DNS-01 challenge was not offered by the CA server.\")\n        return chall\n\n    def _update_dns(self, tokens, domain, zone_id):\n        \"\"\"Update DNS records required for ACME DNS-01 validation.\n\n        Clears any existing `_acme-challenge` TXT records for the domain,\n        builds the TXT record in the domain\u2019s hosted zone, and applies the changes.\n        Returns `False` immediately if no validation tokens are provided.\n\n        Args:\n            tokens (list[str]): Validation token strings for the TXT record.\n            domain (str): The fully qualified domain name being validated.\n            zone_id (str): The hosted zone identifier for the domain.\n\n        Returns:\n            bool: `True` if DNS changes were submitted; `False` if no tokens were\n                provided.\n\n        Raises:\n            Exception: Propagated from DNS change operations when an apply step\n                fails (via `_apply_dns_change`).\n        \"\"\"\n        logger.info(f\"Starting DNS update for {domain} in zone {zone_id}\")\n        if not tokens:\n            return False\n\n        try:\n            self.dns.clear_old_acme_txt(domain, zone_id)\n        except Exception as e:\n            err = f\"Error clearing older acme challenge for {domain}: {e}\"\n            logger.exception(err)\n            # This is just an informational error, no need to return anything here.\n\n        account_record = self.dns.build_domain_validation_record(tokens, domain, zone_id)\n        logger.info(f\"Applying TXT record in zone for {domain}\")\n        self._apply_dns_change(account_record)\n\n        logger.info(f\"DNS update complete for {domain}\")\n        return True\n\n    def _apply_dns_change(self, record):\n        \"\"\"Apply a single DNS change and surface failures.\n\n        Delegates the record update to the DNS plugin and raises any exception\n        encountered so the caller can handle or abort the flow.\n\n        Args:\n            record (dict): DNS record change payload containing an `RRSet` with\n                `Name`, `Type`, `ResourceRecords`, and `TTL`.\n\n        Raises:\n            Exception: Propagates any error raised by the DNS plugin during the\n                change operation.\n        \"\"\"\n        try:\n            self.dns.change_dns(record)\n        except Exception as e:\n            err = f\"Error: DNS change failed for {record['RRSet']['Name']}: {e}\"\n            logger.exception(err)\n            raise e\n\n    def _store_pems(self, domain, pem_list):\n        \"\"\"Store the complete set of certificate materials for a domain.\n\n        Iterates over the provided PEM items, stores each via the secrets plugin,\n        and returns a list of identifiers for the created/updated secrets. A fixed\n        set of resource tags is applied to each stored item.\n\n        Args:\n            domain (str): The fully qualified domain name the materials belong to.\n            pem_list (list[dict]): Iterable of items to store, each dict containing:\n                - 'key' (str): Logical name of the material (e.g., 'csr',\n                  'private_key', 'fullchain').\n                - 'value' (str | bytes): PEM-encoded content to store.\n\n        Returns:\n            list[dict]: A list of dictionaries of the form\n                `{'key': &lt;original key&gt;, 'value': &lt;stored identifier&gt;}` for each\n                successfully stored item. Items that do not return an identifier are\n                omitted from the result.\n        \"\"\"\n        tags = [\n            {\"Key\":\"Owner\",\"Value\":\"Your Team Name\"},\n            {\"Key\":\"Environment\",\"Value\":\"Production\"},\n            {\"Key\":\"Application\",\"Value\":\"tlstool\"},\n            {\"Key\":\"Service\",\"Value\":\"LetsEncrypt\"}\n        ]\n\n        arns = []\n        for pem in pem_list:\n            arn = self.secrets.store_pem_secret(domain, pem, tags)\n            if arn:\n                arns.append({'key': pem['key'], 'value': arn})\n        return arns\n</code></pre>"},{"location":"components/certificates/#tlstool.certificates.CertificateManager-functions","title":"Functions","text":""},{"location":"components/certificates/#tlstool.certificates.CertificateManager.request_cert","title":"request_cert","text":"<pre><code>request_cert(domain, zone_id)\n</code></pre> <p>Request and provision a certificate for a single domain via ACME (LE).</p> <p>Orchestrates the full certificate request flow: creates an ACME order, prepares DNS-01 challenges, updates DNS records, finalizes the order to obtain the full-chain certificate, stores certificate materials in the secrets backend, and, if applicable, restores any prior CNAME record.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Fully qualified domain name to issue/renew a certificate for.</p> required <code>zone_id</code> <code>str</code> <p>Route53 (or provider) hosted zone identifier for the domain.</p> required <p>Returns:</p> Type Description <p>list[dict] | str: On success, a list of objects describing stored certificate materials (e.g., ARNs). On failure, a string error message (e.g., when DNS update fails or ACME finalization returns an error).</p> Notes <ul> <li>Updates DNS records for the ACME DNS-01 challenge and waits for   propagation.</li> <li>Stores the private key, CSR, and full chain in the secrets backend.</li> </ul> Source code in <code>tlstool/certificates.py</code> <pre><code>def request_cert(self, domain: str, zone_id: str):\n    \"\"\"Request and provision a certificate for a single domain via ACME (LE).\n\n    Orchestrates the full certificate request flow:\n    creates an ACME order, prepares DNS-01 challenges, updates DNS records,\n    finalizes the order to obtain the full-chain certificate,\n    stores certificate materials in the secrets backend,\n    and, if applicable, restores any prior CNAME record.\n\n    Args:\n        domain (str): Fully qualified domain name to issue/renew a certificate for.\n        zone_id (str): Route53 (or provider) hosted zone identifier for the domain.\n\n    Returns:\n        list[dict] | str: On success, a list of objects describing stored\n            certificate materials (e.g., ARNs). On failure, a string error\n            message (e.g., when DNS update fails or ACME finalization returns\n            an error).\n\n    Notes:\n        - Updates DNS records for the ACME DNS-01 challenge and waits for\n          propagation.\n        - Stores the private key, CSR, and full chain in the secrets backend.\n    \"\"\"\n    logger.info(f\"Requesting certificate for {domain}\")\n\n    try:\n        client_acme, order_object, pkey_pem, csr_pem = self._begin_acme_order(domain)\n        dns_data = self._prepare_dns_challenges(client_acme, order_object)\n        ready_to_validate = self._update_dns([i[2] for i in dns_data], domain, zone_id)\n\n        if ready_to_validate is not True:\n            return f\"Error: DNS update failed for {domain}\"\n\n        fullchain_pem = self._finalize_acme_order(client_acme, order_object, dns_data, domain)\n        if isinstance(fullchain_pem, str) and fullchain_pem.startswith(\"Error\"):\n            return fullchain_pem\n\n        arns = self._store_cert_materials(domain, pkey_pem, csr_pem, fullchain_pem)\n        return arns\n\n    except Exception as e:\n        err = f\"Unexpected error requesting cert for {domain}: {e}\"\n        logger.exception(err)\n        return err\n</code></pre>"},{"location":"components/domains/","title":"Domains Reference","text":""},{"location":"components/domains/#tlstool.domains","title":"tlstool.domains","text":""},{"location":"components/domains/#tlstool.domains-classes","title":"Classes","text":""},{"location":"components/domains/#tlstool.domains.DomainManager","title":"DomainManager","text":"Source code in <code>tlstool/domains.py</code> <pre><code>class DomainManager:\n    def __init__(self):\n        \"\"\"Initialize the domain manager with renewal window settings.\n\n        Loads the renewal window (in days) from application settings for use in\n        domain selection and renewal logic.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.renewal_window_days = settings.RENEWAL_WINDOW_DAYS\n\n    def search_domains(self):\n        \"\"\"Fetch a list of domains eligible for TLS processing.\n\n        In test mode (`g.testmode`), returns a fixed set of test domain entries with\n        a synthetic expiration date ~10 days in the future. Otherwise, performs two\n        database queries (using a shared base filter) to assemble up to 10 domains:\n\n        1) Domains whose certificates are **not** issued by Let's Encrypt (or issuer\n           is NULL), ordered by `tls_exp_date` ascending, limited to 10.\n        2) If fewer than 10 were found in (1), add domains with Let's Encrypt-issued\n           certificates that expire within `self.renewal_window_days`, ordered by\n           `tls_exp_date` ascending, limited to the remaining slots.\n\n        The base filter excludes parked/expired domains (or NULL status), requires\n        ownership and non-empty zone data, and omits names in a local exclusion\n        list. The result is logged and returned as a list of dictionaries.\n\n        Returns:\n            list[dict]: Domain metadata dicts of the form:\n                {\n                    'domain': str,\n                    'zone_id': str,      # currently mapped from model field\n                    'tls_exp_date': Any, # datetime/date as stored on the model\n                    'tls_issuer': str | None\n                }\n        \"\"\"\n        testmode = getattr(g, 'testmode', None)\n        if testmode:\n            test_date = (datetime.now() + timedelta(days=10)).strftime('%Y-%m-%d 00:00:00')\n            domain_list = [\n                {'domain': 'example.com', 'zone_id': 'zone-XYZ123', 'tls_exp_date': f'{test_date}', 'tls_issuer': ''}\n            ]\n            logger.info(f\"Testing these {len(domain_list)} domains: {domain_list}\")\n            return domain_list\n\n        domain_list = []\n\n        # Use this list to hold any domains in your database that you want to exclude from the TLS process:\n        exclusion_list = ['exampletwo.com', 'examplethree.com']\n\n        with current_app.app_context():\n            base_query = Domain.query.filter(\n                or_(Domain.status.notin_(['Parked', 'Expired']), Domain.status.is_(None)),\n                Domain.zone_id != '',\n                Domain.owned.is_(True),\n                ~Domain.name.in_(exclusion_list),\n            ).order_by(Domain.tls_exp_date.asc())\n\n            logger.info(\"Search for domains with certs not issued by LE\")\n            non_le = base_query.filter(or_(Domain.tls_issuer != 'Lets Encrypt', Domain.tls_issuer.is_(None))).limit(10).all()\n            for t in non_le:\n                domain_list.append({'domain': t.name, 'zone_id': t.zone_id, 'tls_exp_date': t.tls_exp_date, 'tls_issuer': t.tls_issuer})\n\n            remaining = 10 - len(non_le)\n            if remaining &gt; 0:\n                logger.info(\"All active certs issued by LE, within renewal range\")\n                cutoff = datetime.utcnow() + timedelta(days=self.renewal_window_days)\n                le_renew = base_query.filter(\n                    Domain.tls_issuer == 'Lets Encrypt',\n                    Domain.tls_exp_date &lt; cutoff\n                ).limit(remaining).all()\n                for t in le_renew:\n                    domain_list.append({'domain': t.name, 'zone_id': t.zone_id, 'tls_exp_date': t.tls_exp_date, 'tls_issuer': t.tls_issuer})\n\n        logger.info(f\"Processing these {len(domain_list)} domains: {domain_list}\")\n        return domain_list\n\n    def domain_meta(self, domain):\n        \"\"\"Return metadata for a single domain.\n\n        Executes a database query to fetch the selected fields for the given domain\n        and formats the result as a list for consistency with the bulk search API.\n        The list will contain zero or one item depending on whether the domain is\n        found.\n\n        Args:\n        domain (str): The fully qualified domain name to look up.\n\n        Returns:\n        list[dict]: A list containing at most one dictionary with keys:\n        'domain', 'zone_id', 'tls_exp_date', and 'tls_issuer'.\n        \"\"\"\n        domain_list = []\n\n        with current_app.app_context():\n            query = Domain.query.with_entities(\n                Domain.name,\n                Domain.zone_id,\n                Domain.tls_exp_date,\n                Domain.tls_issuer\n            ).filter(\n                Domain.name == domain\n            )\n            domains = query.all()\n            for t in domains:\n                domain_list.append({'domain': t.name, 'zone_id': t.zone_id, 'tls_exp_date': t.tls_exp_date, 'tls_issuer': t.tls_issuer})\n\n        return domain_list\n\n    def get_domain_tls_status(self, domain, tls_issuer):\n        \"\"\"Assess the TLS status of a domain by inspecting its live certificate.\n\n        Fetches the current server certificate from the domain on port 443, parses\n        its expiration and subject names, and classifies status as:\n        - 'ok': certificate valid, domain present in SAN/CN, not expiring soon.\n        - 'renew': certificate valid but expires within 15 days.\n        - 'new': certificate missing domain in SAN/CN or non\u2013Let's Encrypt issuer.\n        - 'unavailable': no certificate could be retrieved (EOF).\n\n        Args:\n            domain (str): Fully qualified domain name to check (assumes HTTPS on 443).\n            tls_issuer (str | None): Known issuer string from metadata; if not\n                equal to 'Lets Encrypt', status is set to 'new'.\n\n        Returns:\n            str: One of {'ok', 'renew', 'new', 'unavailable'} indicating the action\n                needed for this domain.\n\n        Notes:\n            - Uses a 15-day renewal window based on the parsed certificate\n              expiration date.\n            - Logs detailed information and exceptions for troubleshooting.\n        \"\"\"\n        status = 'ok'\n        timestamp = ''\n\n        try:\n            logger.info(f\"Checking {domain} for current certificate\")\n            cert = ssl.get_server_certificate((domain, 443))\n\n            # Load a certificate (X509) from the string `_buffer_` encoded with `_type_`:\n            x509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)\n\n            # Get the timestamp at which the certificate stops being valid:\n            bytes = x509.get_notAfter()\n            timestamp = bytes.decode('utf-8')\n\n            readable_timestamp = datetime.strptime(timestamp, '%Y%m%d%H%M%S%z').date().isoformat()\n            logger.info(f\"Current certificate for {domain} expires on {readable_timestamp}\")\n            exp_obj = datetime.strptime(readable_timestamp, '%Y-%m-%d')\n\n            subjects = self._get_cert_subjects(x509)\n            if domain not in subjects:\n                logger.info(f\"{domain} not in subject list, generate new certificate\")\n                status = 'new'\n\n            if tls_issuer != 'Lets Encrypt':\n                status = 'new'\n\n            expires_in = exp_obj-datetime.now()\n            # if the certificate expires within 15 days, time to renew\n            if expires_in.days &lt; 15:\n                status = 'renew'\n        except ssl.SSLEOFError:\n            logger.exception(f\"No certificate available for {domain}\")\n            status = 'unavailable'\n        except Exception as e:\n            logger.exception(f\"Error retrieving TLS info from {domain}: {e}\")\n            status = \"new\"\n\n        return status\n\n    def _get_cert_subjects(self, x509):\n        \"\"\"Retrieve subject names (SAN and CN) from an X.509 certificate.\n\n        Scans certificate extensions to locate the `subjectAltName`, decodes any DNS\n        names, and returns them as strings. Also appends the certificate\u2019s common\n        name (CN) to the list.\n\n        Args:\n            x509 (OpenSSL.crypto.X509): Parsed certificate object to inspect.\n\n        Returns:\n            list[str]: Domain names present on the certificate (all SAN dNSName\n                entries plus the CN).\n        \"\"\"\n        # Find where the alt names are on the extension list\n        alt_name_index = None\n        for i in range(x509.get_extension_count()):\n            ext_name = x509.get_extension(i).get_short_name().decode('utf-8')\n            if ext_name == 'subjectAltName':\n                alt_name_index = i\n                break\n\n            if alt_name_index is None:\n                logger.debug(\"No subjectAltName extension found.\")\n                return []\n\n        raw_names = x509.get_extension(alt_name_index).get_data()\n        logger.debug(f\"# get_extension().get_data() - Replace with pyca/cryptography's X.509 APIs: index - {alt_name_index}, raw_names - {raw_names}\")\n        decoded_names, _ = asn1_decoder(raw_names, asn1Spec=SubjectAltName())\n        utf_alt_names = nat_encoder(decoded_names)\n        subject_alt_names = [ x['dNSName'].decode('utf-8') for x in utf_alt_names]\n\n        # Top-level subject\n        raw_subject = x509.get_subject()\n        subject = raw_subject.get_components()[0][1].decode('utf_8')\n        subject_alt_names.append(subject) \n        logger.info(f'Subject list: {subject_alt_names}')\n        return subject_alt_names\n\n    @retry_db_transaction(max_retries=3, min_sleep=1, max_sleep=3)\n    def domain_update(self, cert_obj):\n        \"\"\"Update domain database records with certificate metadata.\n\n        Parses the certificate object returned from the upstream provider, inserts a\n        new `Tls` row, and updates the corresponding `Domain` row with the new TLS\n        identifiers and timestamps in a single transactional operation.\n\n        Args:\n            cert_obj (dict): Certificate payload with the shape:\n                {\n                    \"cert\": {\n                        \"data\": {\n                            \"id\": str,  # provider certificate identifier\n                            \"attributes\": {\n                                \"not_after\": str,\n                                \"not_before\": str,\n                                \"created_at\": str\n                            },\n                            \"relationships\": {\n                                \"tls_domains\": {\n                                    \"data\": [{\"id\": str}]  # first item used; may be \"*.example.com\"\n                                }\n                            }\n                        }\n                    }\n                }\n\n        Returns:\n            bool: `True` if the transaction commits and at least one domain row is\n                updated; `False` if an error occurs.\n\n        Notes:\n            - Uses `current_app.app_context()` and a SQLAlchemy session transaction.\n            - Inserts a new `Tls` record, then updates the `Domain` row matching the\n              derived apex domain (wildcard prefix is stripped).\n            - Decorated with `@retry_db_transaction` for automatic retries on failure.\n        \"\"\"\n        ## 1. Parse the certificate object \n        host = cert_obj['cert']['data']['relationships']['tls_domains']['data'][0]['id']\n        domain = host.lstrip('*.')\n        fastly_id = cert_obj['cert']['data']['id']\n        not_after = cert_obj['cert']['data']['attributes']['not_after']\n        not_before = cert_obj['cert']['data']['attributes']['not_before']\n        created_at = cert_obj['cert']['data']['attributes']['created_at']\n        logger.info(f\"Update the domain db to indicate TLS record created for {domain}\")\n\n        ## 2. transactional insert and update\n        try:\n            with current_app.app_context():\n                with db.session.begin():\n                    new_tls = Tls(\n                        fastly_id=fastly_id,\n                        not_after=not_after,\n                        not_before=not_before,\n                        created_at=created_at\n                    )\n                    db.session.add(new_tls)\n                    db.session.flush()  # ensures new_tls.id is populated\n\n                    # Update domain record\n                    stmt = (\n                        update(Domain)\n                        .where(Domain.name == domain)\n                        .values(\n                            tls_id=new_tls.id,\n                            tls_exp_date=not_after,\n                            tls_issuer='Lets Encrypt',\n                            last_updated=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                            last_updated_by='tlstool'\n                        )\n                    )\n\n                    result = db.session.execute(stmt)\n                    if result.rowcount == 0:\n                        raise RuntimeError(f\"No tls record updated for {domain}\")\n\n                logger.info(f\"Domain record for {domain} updated with SSL info at {os.environ['DBHOST']}\")\n                return True\n\n        except (SQLAlchemyError, RuntimeError) as e:\n            logger.exception(f\"Error updating database for {domain}: {e}\")\n            return False\n</code></pre>"},{"location":"components/domains/#tlstool.domains.DomainManager-functions","title":"Functions","text":""},{"location":"components/domains/#tlstool.domains.DomainManager.domain_meta","title":"domain_meta","text":"<pre><code>domain_meta(domain)\n</code></pre> <p>Return metadata for a single domain.</p> <p>Executes a database query to fetch the selected fields for the given domain and formats the result as a list for consistency with the bulk search API. The list will contain zero or one item depending on whether the domain is found.</p> <p>Args: domain (str): The fully qualified domain name to look up.</p> <p>Returns: list[dict]: A list containing at most one dictionary with keys: 'domain', 'zone_id', 'tls_exp_date', and 'tls_issuer'.</p> Source code in <code>tlstool/domains.py</code> <pre><code>def domain_meta(self, domain):\n    \"\"\"Return metadata for a single domain.\n\n    Executes a database query to fetch the selected fields for the given domain\n    and formats the result as a list for consistency with the bulk search API.\n    The list will contain zero or one item depending on whether the domain is\n    found.\n\n    Args:\n    domain (str): The fully qualified domain name to look up.\n\n    Returns:\n    list[dict]: A list containing at most one dictionary with keys:\n    'domain', 'zone_id', 'tls_exp_date', and 'tls_issuer'.\n    \"\"\"\n    domain_list = []\n\n    with current_app.app_context():\n        query = Domain.query.with_entities(\n            Domain.name,\n            Domain.zone_id,\n            Domain.tls_exp_date,\n            Domain.tls_issuer\n        ).filter(\n            Domain.name == domain\n        )\n        domains = query.all()\n        for t in domains:\n            domain_list.append({'domain': t.name, 'zone_id': t.zone_id, 'tls_exp_date': t.tls_exp_date, 'tls_issuer': t.tls_issuer})\n\n    return domain_list\n</code></pre>"},{"location":"components/domains/#tlstool.domains.DomainManager.domain_update","title":"domain_update","text":"<pre><code>domain_update(cert_obj)\n</code></pre> <p>Update domain database records with certificate metadata.</p> <p>Parses the certificate object returned from the upstream provider, inserts a new <code>Tls</code> row, and updates the corresponding <code>Domain</code> row with the new TLS identifiers and timestamps in a single transactional operation.</p> <p>Parameters:</p> Name Type Description Default <code>cert_obj</code> <code>dict</code> <p>Certificate payload with the shape: {     \"cert\": {         \"data\": {             \"id\": str,  # provider certificate identifier             \"attributes\": {                 \"not_after\": str,                 \"not_before\": str,                 \"created_at\": str             },             \"relationships\": {                 \"tls_domains\": {                     \"data\": [{\"id\": str}]  # first item used; may be \"*.example.com\"                 }             }         }     } }</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p><code>True</code> if the transaction commits and at least one domain row is updated; <code>False</code> if an error occurs.</p> Notes <ul> <li>Uses <code>current_app.app_context()</code> and a SQLAlchemy session transaction.</li> <li>Inserts a new <code>Tls</code> record, then updates the <code>Domain</code> row matching the   derived apex domain (wildcard prefix is stripped).</li> <li>Decorated with <code>@retry_db_transaction</code> for automatic retries on failure.</li> </ul> Source code in <code>tlstool/domains.py</code> <pre><code>@retry_db_transaction(max_retries=3, min_sleep=1, max_sleep=3)\ndef domain_update(self, cert_obj):\n    \"\"\"Update domain database records with certificate metadata.\n\n    Parses the certificate object returned from the upstream provider, inserts a\n    new `Tls` row, and updates the corresponding `Domain` row with the new TLS\n    identifiers and timestamps in a single transactional operation.\n\n    Args:\n        cert_obj (dict): Certificate payload with the shape:\n            {\n                \"cert\": {\n                    \"data\": {\n                        \"id\": str,  # provider certificate identifier\n                        \"attributes\": {\n                            \"not_after\": str,\n                            \"not_before\": str,\n                            \"created_at\": str\n                        },\n                        \"relationships\": {\n                            \"tls_domains\": {\n                                \"data\": [{\"id\": str}]  # first item used; may be \"*.example.com\"\n                            }\n                        }\n                    }\n                }\n            }\n\n    Returns:\n        bool: `True` if the transaction commits and at least one domain row is\n            updated; `False` if an error occurs.\n\n    Notes:\n        - Uses `current_app.app_context()` and a SQLAlchemy session transaction.\n        - Inserts a new `Tls` record, then updates the `Domain` row matching the\n          derived apex domain (wildcard prefix is stripped).\n        - Decorated with `@retry_db_transaction` for automatic retries on failure.\n    \"\"\"\n    ## 1. Parse the certificate object \n    host = cert_obj['cert']['data']['relationships']['tls_domains']['data'][0]['id']\n    domain = host.lstrip('*.')\n    fastly_id = cert_obj['cert']['data']['id']\n    not_after = cert_obj['cert']['data']['attributes']['not_after']\n    not_before = cert_obj['cert']['data']['attributes']['not_before']\n    created_at = cert_obj['cert']['data']['attributes']['created_at']\n    logger.info(f\"Update the domain db to indicate TLS record created for {domain}\")\n\n    ## 2. transactional insert and update\n    try:\n        with current_app.app_context():\n            with db.session.begin():\n                new_tls = Tls(\n                    fastly_id=fastly_id,\n                    not_after=not_after,\n                    not_before=not_before,\n                    created_at=created_at\n                )\n                db.session.add(new_tls)\n                db.session.flush()  # ensures new_tls.id is populated\n\n                # Update domain record\n                stmt = (\n                    update(Domain)\n                    .where(Domain.name == domain)\n                    .values(\n                        tls_id=new_tls.id,\n                        tls_exp_date=not_after,\n                        tls_issuer='Lets Encrypt',\n                        last_updated=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                        last_updated_by='tlstool'\n                    )\n                )\n\n                result = db.session.execute(stmt)\n                if result.rowcount == 0:\n                    raise RuntimeError(f\"No tls record updated for {domain}\")\n\n            logger.info(f\"Domain record for {domain} updated with SSL info at {os.environ['DBHOST']}\")\n            return True\n\n    except (SQLAlchemyError, RuntimeError) as e:\n        logger.exception(f\"Error updating database for {domain}: {e}\")\n        return False\n</code></pre>"},{"location":"components/domains/#tlstool.domains.DomainManager.get_domain_tls_status","title":"get_domain_tls_status","text":"<pre><code>get_domain_tls_status(domain, tls_issuer)\n</code></pre> <p>Assess the TLS status of a domain by inspecting its live certificate.</p> <p>Fetches the current server certificate from the domain on port 443, parses its expiration and subject names, and classifies status as: - 'ok': certificate valid, domain present in SAN/CN, not expiring soon. - 'renew': certificate valid but expires within 15 days. - 'new': certificate missing domain in SAN/CN or non\u2013Let's Encrypt issuer. - 'unavailable': no certificate could be retrieved (EOF).</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Fully qualified domain name to check (assumes HTTPS on 443).</p> required <code>tls_issuer</code> <code>str | None</code> <p>Known issuer string from metadata; if not equal to 'Lets Encrypt', status is set to 'new'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>One of {'ok', 'renew', 'new', 'unavailable'} indicating the action needed for this domain.</p> Notes <ul> <li>Uses a 15-day renewal window based on the parsed certificate   expiration date.</li> <li>Logs detailed information and exceptions for troubleshooting.</li> </ul> Source code in <code>tlstool/domains.py</code> <pre><code>def get_domain_tls_status(self, domain, tls_issuer):\n    \"\"\"Assess the TLS status of a domain by inspecting its live certificate.\n\n    Fetches the current server certificate from the domain on port 443, parses\n    its expiration and subject names, and classifies status as:\n    - 'ok': certificate valid, domain present in SAN/CN, not expiring soon.\n    - 'renew': certificate valid but expires within 15 days.\n    - 'new': certificate missing domain in SAN/CN or non\u2013Let's Encrypt issuer.\n    - 'unavailable': no certificate could be retrieved (EOF).\n\n    Args:\n        domain (str): Fully qualified domain name to check (assumes HTTPS on 443).\n        tls_issuer (str | None): Known issuer string from metadata; if not\n            equal to 'Lets Encrypt', status is set to 'new'.\n\n    Returns:\n        str: One of {'ok', 'renew', 'new', 'unavailable'} indicating the action\n            needed for this domain.\n\n    Notes:\n        - Uses a 15-day renewal window based on the parsed certificate\n          expiration date.\n        - Logs detailed information and exceptions for troubleshooting.\n    \"\"\"\n    status = 'ok'\n    timestamp = ''\n\n    try:\n        logger.info(f\"Checking {domain} for current certificate\")\n        cert = ssl.get_server_certificate((domain, 443))\n\n        # Load a certificate (X509) from the string `_buffer_` encoded with `_type_`:\n        x509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert)\n\n        # Get the timestamp at which the certificate stops being valid:\n        bytes = x509.get_notAfter()\n        timestamp = bytes.decode('utf-8')\n\n        readable_timestamp = datetime.strptime(timestamp, '%Y%m%d%H%M%S%z').date().isoformat()\n        logger.info(f\"Current certificate for {domain} expires on {readable_timestamp}\")\n        exp_obj = datetime.strptime(readable_timestamp, '%Y-%m-%d')\n\n        subjects = self._get_cert_subjects(x509)\n        if domain not in subjects:\n            logger.info(f\"{domain} not in subject list, generate new certificate\")\n            status = 'new'\n\n        if tls_issuer != 'Lets Encrypt':\n            status = 'new'\n\n        expires_in = exp_obj-datetime.now()\n        # if the certificate expires within 15 days, time to renew\n        if expires_in.days &lt; 15:\n            status = 'renew'\n    except ssl.SSLEOFError:\n        logger.exception(f\"No certificate available for {domain}\")\n        status = 'unavailable'\n    except Exception as e:\n        logger.exception(f\"Error retrieving TLS info from {domain}: {e}\")\n        status = \"new\"\n\n    return status\n</code></pre>"},{"location":"components/domains/#tlstool.domains.DomainManager.search_domains","title":"search_domains","text":"<pre><code>search_domains()\n</code></pre> <p>Fetch a list of domains eligible for TLS processing.</p> <p>In test mode (<code>g.testmode</code>), returns a fixed set of test domain entries with a synthetic expiration date ~10 days in the future. Otherwise, performs two database queries (using a shared base filter) to assemble up to 10 domains:</p> <p>1) Domains whose certificates are not issued by Let's Encrypt (or issuer    is NULL), ordered by <code>tls_exp_date</code> ascending, limited to 10. 2) If fewer than 10 were found in (1), add domains with Let's Encrypt-issued    certificates that expire within <code>self.renewal_window_days</code>, ordered by    <code>tls_exp_date</code> ascending, limited to the remaining slots.</p> <p>The base filter excludes parked/expired domains (or NULL status), requires ownership and non-empty zone data, and omits names in a local exclusion list. The result is logged and returned as a list of dictionaries.</p> <p>Returns:</p> Type Description <p>list[dict]: Domain metadata dicts of the form: {     'domain': str,     'zone_id': str,      # currently mapped from model field     'tls_exp_date': Any, # datetime/date as stored on the model     'tls_issuer': str | None }</p> Source code in <code>tlstool/domains.py</code> <pre><code>def search_domains(self):\n    \"\"\"Fetch a list of domains eligible for TLS processing.\n\n    In test mode (`g.testmode`), returns a fixed set of test domain entries with\n    a synthetic expiration date ~10 days in the future. Otherwise, performs two\n    database queries (using a shared base filter) to assemble up to 10 domains:\n\n    1) Domains whose certificates are **not** issued by Let's Encrypt (or issuer\n       is NULL), ordered by `tls_exp_date` ascending, limited to 10.\n    2) If fewer than 10 were found in (1), add domains with Let's Encrypt-issued\n       certificates that expire within `self.renewal_window_days`, ordered by\n       `tls_exp_date` ascending, limited to the remaining slots.\n\n    The base filter excludes parked/expired domains (or NULL status), requires\n    ownership and non-empty zone data, and omits names in a local exclusion\n    list. The result is logged and returned as a list of dictionaries.\n\n    Returns:\n        list[dict]: Domain metadata dicts of the form:\n            {\n                'domain': str,\n                'zone_id': str,      # currently mapped from model field\n                'tls_exp_date': Any, # datetime/date as stored on the model\n                'tls_issuer': str | None\n            }\n    \"\"\"\n    testmode = getattr(g, 'testmode', None)\n    if testmode:\n        test_date = (datetime.now() + timedelta(days=10)).strftime('%Y-%m-%d 00:00:00')\n        domain_list = [\n            {'domain': 'example.com', 'zone_id': 'zone-XYZ123', 'tls_exp_date': f'{test_date}', 'tls_issuer': ''}\n        ]\n        logger.info(f\"Testing these {len(domain_list)} domains: {domain_list}\")\n        return domain_list\n\n    domain_list = []\n\n    # Use this list to hold any domains in your database that you want to exclude from the TLS process:\n    exclusion_list = ['exampletwo.com', 'examplethree.com']\n\n    with current_app.app_context():\n        base_query = Domain.query.filter(\n            or_(Domain.status.notin_(['Parked', 'Expired']), Domain.status.is_(None)),\n            Domain.zone_id != '',\n            Domain.owned.is_(True),\n            ~Domain.name.in_(exclusion_list),\n        ).order_by(Domain.tls_exp_date.asc())\n\n        logger.info(\"Search for domains with certs not issued by LE\")\n        non_le = base_query.filter(or_(Domain.tls_issuer != 'Lets Encrypt', Domain.tls_issuer.is_(None))).limit(10).all()\n        for t in non_le:\n            domain_list.append({'domain': t.name, 'zone_id': t.zone_id, 'tls_exp_date': t.tls_exp_date, 'tls_issuer': t.tls_issuer})\n\n        remaining = 10 - len(non_le)\n        if remaining &gt; 0:\n            logger.info(\"All active certs issued by LE, within renewal range\")\n            cutoff = datetime.utcnow() + timedelta(days=self.renewal_window_days)\n            le_renew = base_query.filter(\n                Domain.tls_issuer == 'Lets Encrypt',\n                Domain.tls_exp_date &lt; cutoff\n            ).limit(remaining).all()\n            for t in le_renew:\n                domain_list.append({'domain': t.name, 'zone_id': t.zone_id, 'tls_exp_date': t.tls_exp_date, 'tls_issuer': t.tls_issuer})\n\n    logger.info(f\"Processing these {len(domain_list)} domains: {domain_list}\")\n    return domain_list\n</code></pre>"},{"location":"components/domains/#tlstool.domains-functions","title":"Functions","text":""},{"location":"components/orchestrator/","title":"Orchestrator Reference","text":""},{"location":"components/orchestrator/#tlstool.orchestrator","title":"tlstool.orchestrator","text":""},{"location":"components/orchestrator/#tlstool.orchestrator-classes","title":"Classes","text":""},{"location":"components/orchestrator/#tlstool.orchestrator-functions","title":"Functions","text":""},{"location":"components/orchestrator/#tlstool.orchestrator.cert_flow","title":"cert_flow","text":"<pre><code>cert_flow(domain_list, process_domain_fn=None)\n</code></pre> <p>Process domains through the certificate issuance/renewal pipeline.</p> <p>For each domain this function: 1. Check TLS to determine if a new/renewed certificate is required. 2. If required, request a certificate with Let\u2019s Encrypt (ACME). 3. Store the certificate and private key in AWS Secrets Manager. 4. Upload the certificate/private key to Fastly. 5. Update the domain database to indicate <code>ssl_created</code>.</p> <p>Domains are processed concurrently via a <code>ThreadPoolExecutor</code>, with per-domain thread names for clearer logs. Per-domain processing time is recorded. An optional <code>process_domain_fn</code> can be injected for testing/mocking.</p> <p>Args: domain_list (list[dict]): Iterable of domain metadata dicts to process. process_domain_fn (Callable[[dict, str | None, flask.Flask], dict] | None):     Optional replacement for the internal per-domain worker; primarily     used for tests or mocks. If provided, it must accept arguments     <code>(domain_dict, testmode, app)</code> and return a per-domain result dict.</p> <p>Returns: bool: <code>True</code> after all submitted domain tasks have completed.</p> Source code in <code>tlstool/orchestrator.py</code> <pre><code>def cert_flow(domain_list, process_domain_fn=None):\n    \"\"\"Process domains through the certificate issuance/renewal pipeline.\n\n    For each domain this function:\n    1. Check TLS to determine if a new/renewed certificate is required.\n    2. If required, request a certificate with Let\u2019s Encrypt (ACME).\n    3. Store the certificate and private key in AWS Secrets Manager.\n    4. Upload the certificate/private key to Fastly.\n    5. Update the domain database to indicate `ssl_created`.\n\n    Domains are processed concurrently via a `ThreadPoolExecutor`, with\n    per-domain thread names for clearer logs. Per-domain processing time is\n    recorded. An optional `process_domain_fn` can be injected for testing/mocking.\n\n    Args:\n    domain_list (list[dict]): Iterable of domain metadata dicts to process.\n    process_domain_fn (Callable[[dict, str | None, flask.Flask], dict] | None):\n        Optional replacement for the internal per-domain worker; primarily\n        used for tests or mocks. If provided, it must accept arguments\n        `(domain_dict, testmode, app)` and return a per-domain result dict.\n\n    Returns:\n    bool: `True` after all submitted domain tasks have completed.\n    \"\"\"\n    testmode = getattr(g, 'testmode', None)\n    app = current_app._get_current_object()  # capture the real app instance\n\n    def _process_domain(d, testmode, app):\n        start_time = time.time()\n        domain = d['domain'].lower()\n        response_dict = {'domain': domain, 'messages': '', 'errors': []}\n\n        thread_name = f\"Domain-{domain}\"\n        original_thread_name = threading.current_thread().name\n        threading.current_thread().name = thread_name\n\n        try:\n            with app.app_context():\n\n                logger.info(f\"[{thread_name}] Starting processing for domain: {domain}\")\n\n                tls_issuer = d['tls_issuer']\n                zone_id = d['zone_id']\n\n                certificate_status = domains.get_domain_tls_status(domain, tls_issuer)\n\n                if certificate_status == 'ok':\n                    response_dict['certificate_status'] = certificate_status\n                    response_dict['messages'] = f\"Not due for renewal: {domain}\"\n                elif certificate_status in ('new', 'renew'):\n                    response_dict['certificate_status'] = certificate_status\n                    certificate_ids = certificates.request_cert(\n                        domain=domain,\n                        zone_id=zone_id\n                    )\n                    response_dict = validate_certificate_request(certificate_ids, response_dict)\n                    certificate_object, response_dict = upload_certificate(domain, certificate_ids, response_dict, testmode)\n                    response_dict = domain_metadata_update(certificate_object, response_dict, testmode)\n                else:\n                    response_dict['certificate_status'] = 'unavailable'\n                    response_dict['errors'].append(certificate_status)\n\n                if response_dict['errors']:\n                    logger.info(f\"[{thread_name}] Errors on {domain}: {response_dict['errors']}\")\n                    slack_error_notify(response_dict)\n                else:\n                    logger.info(f\"[{thread_name}] Successfully processed {domain}\")\n                    slack_notify([response_dict])\n\n        except Exception as e:\n            logger.exception(f\"[{thread_name}] Unexpected error processing {domain}: {e}\")\n            response_dict['errors'].append(str(e))\n            slack_error_notify(response_dict)\n\n        finally:\n            duration = time.time() - start_time\n            logger.info(f\"[{thread_name}] Finished processing for domain: {domain} (took {duration:.2f}s)\")\n            threading.current_thread().name = original_thread_name\n\n        return response_dict\n\n    # Use injected function if provided\n    _process_domain_to_use = process_domain_fn or _process_domain\n\n    max_workers = min(5, len(domain_list))\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = [executor.submit(_process_domain_to_use, d, testmode, app) for d in domain_list]\n        for future in as_completed(futures):\n            future.result()\n\n    return True\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.domain_metadata_update","title":"domain_metadata_update","text":"<pre><code>domain_metadata_update(\n    certificate_object, response_dict, testmode\n)\n</code></pre> <p>Update domain metadata in storage based on certificate details.</p> <p>In test mode, synthesizes a fake certificate payload (with fixed validity dates and a wildcard domain relationship), logs the action, and updates the domain record without performing any external uploads. Outside test mode, when no prior errors exist, sets a human-readable expiration message on the response and updates the domain record using the provided certificate object.</p> <p>Parameters:</p> Name Type Description Default <code>certificate_object</code> <code>dict | None</code> <p>Certificate payload expected to include <code>cert.data.attributes.not_after</code> when not in test mode. Ignored in test mode, where a synthetic object is created.</p> required <code>response_dict</code> <code>dict</code> <p>Mutable response accumulator containing an <code>'errors'</code> list and a <code>'messages'</code> field that may be updated.</p> required <code>testmode</code> <code>Any</code> <p>Truthy value enables test behavior and synthetic metadata.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The (potentially mutated) <code>response_dict</code> after updating messages and persisting domain metadata.</p> <p>Notes: - Persists changes via <code>domains.domain_update(...)</code>. - Logs when operating in test mode.</p> Source code in <code>tlstool/orchestrator.py</code> <pre><code>def domain_metadata_update(certificate_object, response_dict, testmode):\n    \"\"\"Update domain metadata in storage based on certificate details.\n\n    In test mode, synthesizes a fake certificate payload (with fixed validity\n    dates and a wildcard domain relationship), logs the action, and updates the\n    domain record without performing any external uploads. Outside test mode,\n    when no prior errors exist, sets a human-readable expiration message on the\n    response and updates the domain record using the provided certificate\n    object.\n\n    Args:\n        certificate_object (dict | None): Certificate payload expected to include\n            `cert.data.attributes.not_after` when not in test mode. Ignored in\n            test mode, where a synthetic object is created.\n        response_dict (dict): Mutable response accumulator containing an `'errors'`\n            list and a `'messages'` field that may be updated.\n        testmode (Any): Truthy value enables test behavior and synthetic metadata.\n\n    Returns:\n        dict: The (potentially mutated) `response_dict` after updating messages\n            and persisting domain metadata.\n\n    Notes:\n    - Persists changes via `domains.domain_update(...)`.\n    - Logs when operating in test mode.\n    \"\"\"\n    if testmode:\n        domain = response_dict.get('domain', 'example.com')\n\n        data = {\n            'id': f'FAKE-{domain}',\n            'attributes': {\n                'not_after': '2099-01-01T00:00:00Z',\n                'not_before': '2025-01-01T00:00:00Z',\n                'created_at': datetime.utcnow().strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n            },\n            'relationships': {\n                'tls_domains': {'data': [{'id': f'*.{domain}'}]}\n            }\n        }\n        certificate_object = {'cert': {'data': data}}\n        logger.info(f\"Test mode, updating DB only for {domain}\")\n        domains.domain_update(certificate_object)\n        return response_dict\n\n    if not response_dict['errors']:\n        response_dict['messages'] = \"Certificate expires: \" + certificate_object['cert']['data']['attributes']['not_after']\n        domains.domain_update(certificate_object)\n    return response_dict\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.process_domains","title":"process_domains","text":"<pre><code>process_domains()\n</code></pre> <p>Process a list of eligible domains through the certificate workflow.</p> <p>Validates the request header key, optionally enables test mode, retrieves the set of eligible domains, and either triggers the certificate flow or posts a Slack notification when there is nothing to process.</p> <p>Returns:</p> Type Description <p>flask.Response: A 200 response with a message when no certificates are due for renewal. Otherwise, the response returned by <code>run_cert_flow(domain_list)</code> (typically 200 on success or 400 on failure).</p> <p>Raises:</p> Type Description <code>Unauthorized</code> <p>If the <code>Flask-Key</code> header is missing or incorrect (raised via <code>validate_header_key()</code>).</p> Notes <ul> <li>Test mode can be enabled via the <code>testmode</code> query parameter.</li> <li>Sends a Slack notification when there are no domains to process.</li> <li>This route is registered at <code>/process</code> under the <code>orchestrator</code>   blueprint.</li> </ul> Source code in <code>tlstool/orchestrator.py</code> <pre><code>@bp.route(\"/process\")\ndef process_domains():\n    \"\"\"Process a list of eligible domains through the certificate workflow.\n\n    Validates the request header key, optionally enables test mode, retrieves the\n    set of eligible domains, and either triggers the certificate flow or posts a\n    Slack notification when there is nothing to process.\n\n    Returns:\n        flask.Response: A 200 response with a message when no certificates are\n            due for renewal. Otherwise, the response returned by\n            `run_cert_flow(domain_list)` (typically 200 on success or 400 on\n            failure).\n\n    Raises:\n        werkzeug.exceptions.Unauthorized: If the `Flask-Key` header is missing\n            or incorrect (raised via `validate_header_key()`).\n\n    Notes:\n        - Test mode can be enabled via the `testmode` query parameter.\n        - Sends a Slack notification when there are no domains to process.\n        - This route is registered at `/process` under the `orchestrator`\n          blueprint.\n    \"\"\"\n    validate_header_key(request.headers)\n    set_test_mode(request.args)\n    domain_list = domains.search_domains()\n    if not domain_list:\n        message = \"No new certificates needed, none currently due for renewal\"\n        c = [{'domain': '', 'certificate_status': '', 'messages': message, 'errors': ''}]\n        slack_notify(c)\n        return Response(message, status=200)\n\n    response = run_cert_flow(domain_list)\n    return response\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.process_single_domain","title":"process_single_domain","text":"<pre><code>process_single_domain(domain=None)\n</code></pre> <p>Process a single domain through the certificate workflow.</p> <p>Validates the request header key, optionally enables test mode, looks up metadata for the given domain, and either triggers the certificate flow or posts a Slack notification if the domain is not eligible.</p> <p>Args: domain (str | None): The fully qualified domain name to process, taken from the URL path segment.</p> <p>Returns: flask.Response: A 200 response with a message when the domain is not available for TLS. Otherwise, the response returned by run_cert_flow(domain_list) (typically 200 on success or 400 on failure).</p> <p>Raises: werkzeug.exceptions.Unauthorized: If the Flask-Key header is missing or incorrect (raised via validate_header_key()).</p> <p>Notes: - Test mode can be enabled via the testmode query parameter. - Sends a Slack notification when the domain is not eligible. - This route is registered at /single/ under the orchestrator blueprint. Source code in <code>tlstool/orchestrator.py</code> <pre><code>@bp.route('/single/&lt;string:domain&gt;')\ndef process_single_domain(domain=None):\n    \"\"\"Process a single domain through the certificate workflow.\n\n    Validates the request header key, optionally enables test mode, looks up metadata\n    for the given domain, and either triggers the certificate flow or posts a Slack\n    notification if the domain is not eligible.\n\n    Args:\n    domain (str | None): The fully qualified domain name to process, taken from\n    the URL path segment.\n\n    Returns:\n    flask.Response: A 200 response with a message when the domain is not\n    available for TLS. Otherwise, the response returned by\n    run_cert_flow(domain_list) (typically 200 on success or 400 on failure).\n\n    Raises:\n    werkzeug.exceptions.Unauthorized: If the Flask-Key header is missing or\n    incorrect (raised via validate_header_key()).\n\n    Notes:\n    - Test mode can be enabled via the testmode query parameter.\n    - Sends a Slack notification when the domain is not eligible.\n    - This route is registered at /single/&lt;domain&gt; under the orchestrator blueprint.\n    \"\"\"\n    validate_header_key(request.headers)\n    set_test_mode(request.args)\n    domain_list = domains.domain_meta(domain)\n    if not domain_list:\n        message = f\"Domain {domain} not available for TLS\"\n        c = [{'domain': domain, 'certificate_status': '', 'messages': message, 'errors': ''}]\n        slack_notify(c)\n        return Response(message, status=200)\n\n    response = run_cert_flow(domain_list)\n    return response\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.run_cert_flow","title":"run_cert_flow","text":"<pre><code>run_cert_flow(domain_list)\n</code></pre> <p>Run the certificate flow and return an HTTP response.</p> <p>Executes the <code>cert_flow</code> pipeline for the provided domains and converts the outcome into an HTTP response: 200 on success, 400 on failure. On error, posts a Slack error notification before returning the failure status.</p> <p>Args: domain_list (list[dict]): Iterable of domain metadata dicts to process.</p> <p>flask.Response: An empty response with status 200 if the flow completes     successfully; otherwise an empty response with status 400.</p> <p>Notes: All exceptions raised by <code>cert_flow</code> are caught, logged, and reported to Slack; this function itself does not re-raise.</p> Source code in <code>tlstool/orchestrator.py</code> <pre><code>def run_cert_flow(domain_list):\n    \"\"\"Run the certificate flow and return an HTTP response.\n\n    Executes the `cert_flow` pipeline for the provided domains and converts the\n    outcome into an HTTP response: 200 on success, 400 on failure. On error,\n    posts a Slack error notification before returning the failure status.\n\n    Args:\n    domain_list (list[dict]): Iterable of domain metadata dicts to process.\n\n    Returns:\n    flask.Response: An empty response with status 200 if the flow completes\n        successfully; otherwise an empty response with status 400.\n\n    Notes:\n    All exceptions raised by `cert_flow` are caught, logged, and reported to\n    Slack; this function itself does not re-raise.\n    \"\"\"\n    try:\n        cert_flow(domain_list)\n        status = 200\n    except Exception as e:\n        message = f\"Certificate flow failed on: {e}\"\n        slack_error_notify({'domain': 'All', 'errors': [message]})\n        status = 400\n    return Response(\"\", status=status)\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.set_test_mode","title":"set_test_mode","text":"<pre><code>set_test_mode(request_args)\n</code></pre> <p>Enable test mode based on environment or request parameters.</p> <p>Forces test mode for <code>local</code> and <code>staging</code> environments, or enables it when the <code>testmode</code> query parameter is present. When enabled, sets <code>flask.g.testmode = 'test'</code> and logs an informational message.</p> <p>Args: request_args: The request argument mapping (e.g., <code>flask.request.args</code>).</p> <p>Returns: str | None: Returns <code>'test'</code> when test mode is enabled; otherwise <code>None</code>.</p> <p>Notes: Test mode limits the domains processed and prevents posting to Fastly.</p> Source code in <code>tlstool/orchestrator.py</code> <pre><code>def set_test_mode(request_args):\n    \"\"\"Enable test mode based on environment or request parameters.\n\n    Forces test mode for `local` and `staging` environments, or enables it when\n    the `testmode` query parameter is present. When enabled, sets\n    `flask.g.testmode = 'test'` and logs an informational message.\n\n    Args:\n    request_args: The request argument mapping (e.g., `flask.request.args`).\n\n    Returns:\n    str | None: Returns `'test'` when test mode is enabled; otherwise `None`.\n\n    Notes:\n    Test mode limits the domains processed and prevents posting to Fastly.\n    \"\"\"\n    testmode = None\n    if str(ENV) in ('local', 'staging'):\n        testmode = 'test'\n    else:\n        testmode = request_args.get('testmode')\n    if testmode:\n        g.testmode = 'test'\n        logger.info(\"Entering test mode: limited domain(s) and no posting to Fastly\")\n    return testmode\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.slack_error_notify","title":"slack_error_notify","text":"<pre><code>slack_error_notify(slack_dict)\n</code></pre> <p>Send a Slack notification for a single fatal error.</p> <p>Always builds the Slack block. Sends only in production when ENABLE_SLACK_NOTIFICATIONS is true and webhook creds are present. Otherwise, logs the JSON payload and returns it.</p> <p>slack_dict (dict): Error context containing at least:     - 'domain' (str): The domain associated with the error.     - 'errors' (Any): Error details to include in the message.</p> <p>str: The Slack API response text when posting in production; otherwise     the JSON payload string that was logged and would be sent.</p> Source code in <code>tlstool/orchestrator.py</code> <pre><code>def slack_error_notify(slack_dict):\n    \"\"\"Send a Slack notification for a single fatal error.\n\n    Always builds the Slack block. Sends only in production when\n    ENABLE_SLACK_NOTIFICATIONS is true and webhook creds are present.\n    Otherwise, logs the JSON payload and returns it.\n\n    Args:\n    slack_dict (dict): Error context containing at least:\n        - 'domain' (str): The domain associated with the error.\n        - 'errors' (Any): Error details to include in the message.\n\n    Returns:\n    str: The Slack API response text when posting in production; otherwise\n        the JSON payload string that was logged and would be sent.\n    \"\"\"\n    t = datetime.today()\n    today = t.strftime(\"%m-%d-%Y\")\n    section_text = f\"TLS tool error at {today} ({ENV})\\n\"\n    section_text += f\"{slack_dict['domain']}: {slack_dict['errors']}\"\n    slack_block = {\n        \"text\": f\"TLS tool error(s) at ({ENV})\",\n        \"blocks\": [\n            {\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": section_text}}\n        ],\n    }\n    payload = json.dumps(slack_block)\n\n    if ENV != \"production\" or not getattr(settings, \"ENABLE_SLACK_NOTIFICATIONS\", False):\n        logger.info(f\"[Slack disabled] Slack Error Payload: {payload}\")\n        return payload\n\n    slack_key = getattr(settings, \"SLACK_WEBHOOK_KEY\", None)\n    slack_ws = getattr(settings, \"SLACK_WORKSPACE_ID\", None)\n\n    if not slack_key or not slack_ws:\n        logger.warning(\n            \"Slack notifications enabled but SLACK_WEBHOOK_KEY/SLACK_WORKSPACE_ID are missing. \"\n            \"Logging payload instead.\"\n        )\n        logger.info(f\"Slack Error Payload: {payload}\")\n        return payload\n\n    slack_webhook = f\"https://hooks.slack.com/services/{slack_ws}/{slack_key}\"\n\n    try:\n        r = requests.post(\n            slack_webhook,\n            data=payload,\n            headers={\"Content-Type\": \"application/json\"},\n            timeout=5,\n        )\n        r.raise_for_status()\n        return r.text\n    except requests.RequestException as e:\n        logger.exception(\"Slack post failed; logging payload instead.\")\n        logger.info(f\"Slack Error Payload: {payload}\")\n        return str(e)\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.slack_notify","title":"slack_notify","text":"<pre><code>slack_notify(slack_list)\n</code></pre> <p>Send a Slack notification summarizing a full certificate run.</p> <p>Always builds the Slack block. Sends only in production when ENABLE_SLACK_NOTIFICATIONS is true and webhook creds are present. Otherwise, logs the JSON payload and returns it.</p> <p>Parameters:</p> Name Type Description Default <code>slack_list</code> <code>list[dict]</code> <p>A list of per-domain result dictionaries, each containing <code>domain</code>, <code>certificate_status</code>, <code>messages</code>, and <code>errors</code>.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The Slack API response text when posting in production, otherwise the JSON payload string that was logged and would be sent.</p> Source code in <code>tlstool/orchestrator.py</code> <pre><code>def slack_notify(slack_list):\n    \"\"\"Send a Slack notification summarizing a full certificate run.\n\n    Always builds the Slack block. Sends only in production when\n    ENABLE_SLACK_NOTIFICATIONS is true and webhook creds are present.\n    Otherwise, logs the JSON payload and returns it.\n\n    Args:\n        slack_list (list[dict]): A list of per-domain result dictionaries,\n            each containing `domain`, `certificate_status`, `messages`, and\n            `errors`.\n\n    Returns:\n        str: The Slack API response text when posting in production, otherwise\n            the JSON payload string that was logged and would be sent.\n    \"\"\"\n    t = datetime.today()\n    today = t.strftime('%m-%d-%Y')\n    section_text = f\"Certificate update (tlstool {ENV}) \"\n    section_text += '\\n'.join([ f\"{x['domain']}: {x['certificate_status'].title()} {x['messages']} {x['errors']}\" for x in slack_list ])\n    slack_block = {\n        \"text\": f\"Updated certificates for {today} ({ENV})\",\n        \"blocks\": [\n            {\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": section_text}}\n        ]\n    }\n    payload = json.dumps(slack_block)\n\n    if ENV != \"production\" or not getattr(settings, \"ENABLE_SLACK_NOTIFICATIONS\", False):\n        logger.info(f\"[Slack disabled] Slack Error Payload: {payload}\")\n        return payload\n\n    slack_key = getattr(settings, \"SLACK_WEBHOOK_KEY\", None)\n    slack_ws = getattr(settings, \"SLACK_WORKSPACE_ID\", None)\n\n    if not slack_key or not slack_ws:\n        logger.warning(\n            \"Slack notifications enabled but SLACK_WEBHOOK_KEY/SLACK_WORKSPACE_ID are missing. \"\n            \"Logging payload instead.\"\n        )\n        logger.info(f\"Slack Payload: {payload}\")\n        return payload\n\n    slack_webhook = f\"https://hooks.slack.com/services/{slack_ws}/{slack_key}\"\n\n    try:\n        r = requests.post(\n            slack_webhook,\n            data=payload,\n            headers={\"Content-Type\": \"application/json\"},\n            timeout=5,\n        )\n        r.raise_for_status()\n        return r.text\n    except requests.RequestException as e:\n        logger.exception(\"Slack post failed; logging payload instead.\")\n        logger.info(f\"Slack Error Payload: {payload}\")\n        return str(e)\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.upload_certificate","title":"upload_certificate","text":"<pre><code>upload_certificate(\n    domain, certificate_ids, response_dict, testmode\n)\n</code></pre> <p>Load or synthesize a certificate object and update the response.</p> <p>When no prior errors exist, either synthesizes a test certificate object in test mode or loads certificate material via storage for the given domain and identifiers. Any non-dict result or value containing the substring \"Error\" is treated as a failure and appended to <code>response_dict['errors']</code>.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The fully qualified domain name being processed.</p> required <code>certificate_ids</code> <code>Any</code> <p>Identifiers or metadata needed by storage to load the certificate (type is storage-implementation specific).</p> required <code>response_dict</code> <code>dict</code> <p>Mutable response accumulator containing <code>'errors'</code> and <code>'messages'</code> fields.</p> required <code>testmode</code> <code>Any</code> <p>Truthy value enables test behavior (no external upload).</p> required <p>Returns:</p> Type Description <p>tuple[dict | None, dict]: A tuple of <code>(certificate_object, response_dict)</code>, where <code>certificate_object</code> is a dict in success or <code>None</code> if not set, and <code>response_dict</code> is the (mutated) accumulator.</p> Source code in <code>tlstool/orchestrator.py</code> <pre><code>def upload_certificate(domain, certificate_ids, response_dict, testmode):\n    \"\"\"Load or synthesize a certificate object and update the response.\n\n    When no prior errors exist, either synthesizes a test certificate object in\n    test mode or loads certificate material via storage for the given domain and\n    identifiers. Any non-dict result or value containing the substring \"Error\"\n    is treated as a failure and appended to `response_dict['errors']`.\n\n    Args:\n        domain (str): The fully qualified domain name being processed.\n        certificate_ids (Any): Identifiers or metadata needed by storage to\n            load the certificate (type is storage-implementation specific).\n        response_dict (dict): Mutable response accumulator containing `'errors'`\n            and `'messages'` fields.\n        testmode (Any): Truthy value enables test behavior (no external upload).\n\n    Returns:\n        tuple[dict | None, dict]: A tuple of `(certificate_object, response_dict)`,\n            where `certificate_object` is a dict in success or `None` if not set,\n            and `response_dict` is the (mutated) accumulator.\n    \"\"\"\n    certificate_object = None\n    if not response_dict['errors']:\n        if testmode:\n            certificate_object = {'pkey': 'test', 'cert': 'test'}\n            response_dict['messages'] += \"Test cert created from Lets Encrypt, loaded to AWS Secrets Manager, not uploaded to Fastly\"\n        else:\n            certificate_object = storage.load_certificate(domain, certificate_ids)\n        if (not isinstance(certificate_object, dict)) or ('Error' in str(certificate_object)):\n            response_dict['errors'].append(str(certificate_object))\n    return certificate_object, response_dict\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.validate_certificate_request","title":"validate_certificate_request","text":"<pre><code>validate_certificate_request(\n    certificate_ids, response_dict\n)\n</code></pre> <p>Append certificate request errors to the response accumulator.</p> <p>Interprets a string <code>certificate_ids</code> value as an error message and appends it to <code>response_dict['errors']</code>. Non-string values are treated as success and leave the response unchanged.</p> <p>certificate_ids (Any): Result from the certificate request step. A     string is treated as an error message; other types indicate success. response_dict (dict): Mutable response accumulator containing an     <code>'errors'</code> list.</p> <p>dict: The updated <code>response_dict</code> (same object), potentially with the     error message appended.</p> <p>Notes: This function mutates <code>response_dict</code> in place.</p> Source code in <code>tlstool/orchestrator.py</code> <pre><code>def validate_certificate_request(certificate_ids, response_dict):\n    \"\"\"Append certificate request errors to the response accumulator.\n\n    Interprets a string `certificate_ids` value as an error message and appends\n    it to `response_dict['errors']`. Non-string values are treated as success\n    and leave the response unchanged.\n\n    Args:\n    certificate_ids (Any): Result from the certificate request step. A\n        string is treated as an error message; other types indicate success.\n    response_dict (dict): Mutable response accumulator containing an\n        `'errors'` list.\n\n    Returns:\n    dict: The updated `response_dict` (same object), potentially with the\n        error message appended.\n\n    Notes:\n    This function mutates `response_dict` in place.\n    \"\"\"\n    if isinstance(certificate_ids, str):\n        response_dict['errors'].append(certificate_ids)\n    return response_dict\n</code></pre>"},{"location":"components/orchestrator/#tlstool.orchestrator.validate_header_key","title":"validate_header_key","text":"<pre><code>validate_header_key(request_headers)\n</code></pre> <p>Validate the shared request header key and enforce access control.</p> <p>Checks the <code>Flask-Key</code> header against the application's secret key. On mismatch or absence, posts a Slack error notification, logs the failure, and aborts the request with HTTP 401.</p> <p>request_headers (Mapping[str, str]): Incoming request headers (e.g.,     <code>flask.request.headers</code>).</p> <p>Returns: None: Continues execution when the header is present and valid.</p> <p>werkzeug.exceptions.Unauthorized: Raised via <code>flask.abort(401)</code> when the     header is missing or incorrect.</p> <p>Notes: Sends a Slack error notification on failure before aborting.</p> Source code in <code>tlstool/orchestrator.py</code> <pre><code>def validate_header_key(request_headers):\n    \"\"\"Validate the shared request header key and enforce access control.\n\n    Checks the `Flask-Key` header against the application's secret key. On\n    mismatch or absence, posts a Slack error notification, logs the failure, and\n    aborts the request with HTTP 401.\n\n    Args:\n    request_headers (Mapping[str, str]): Incoming request headers (e.g.,\n        `flask.request.headers`).\n\n    Returns:\n    None: Continues execution when the header is present and valid.\n\n    Raises:\n    werkzeug.exceptions.Unauthorized: Raised via `flask.abort(401)` when the\n        header is missing or incorrect.\n\n    Notes:\n    Sends a Slack error notification on failure before aborting.\n    \"\"\"\n    if request_headers.get('Flask-Key'):\n        if request_headers['Flask-Key'] == current_app.secret_key:\n            pass\n        else:\n            err = \"Error: Certificate flow failed on: Incorrect key value\"\n            slack_error_notify({'domain': 'All', 'errors': [err]})\n            logger.error(err)\n            abort(401)\n    else:\n        err = \"Error: Certificate flow failed on: Missing key value\"\n        slack_error_notify({'domain': 'All', 'errors': [err]})\n        logger.error(err)\n        abort(401)\n</code></pre>"},{"location":"components/plugins/","title":"Components Reference","text":""},{"location":"components/plugins/#dns","title":"DNS","text":""},{"location":"components/plugins/#tlstool.dns","title":"tlstool.dns","text":""},{"location":"components/plugins/#tlstool.dns-classes","title":"Classes","text":""},{"location":"components/plugins/#tlstool.dns.DNSBase","title":"DNSBase","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for DNS management plugins. Implementations should be idempotent and raise DNSError on recoverable DNS failures.</p> Source code in <code>tlstool/dns/__init__.py</code> <pre><code>class DNSBase(ABC):\n    \"\"\"\n    Abstract base class for DNS management plugins.\n    Implementations should be idempotent and raise DNSError on recoverable DNS failures.\n    \"\"\"\n\n    class DNSError(Exception):\n        \"\"\"Raised for DNS-related failures.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_dns_client(self) -&gt; Any:\n        \"\"\"Return the underlying DNS API client/session used by the plugin.\"\"\"\n        pass\n\n    @abstractmethod\n    def find_acme_record(self, zone_id: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Locate an existing `_acme-challenge` RRSet in the given hosted zone, if any.\"\"\"\n        pass\n\n    @abstractmethod\n    def change_dns(self, record: Dict[str, Any]) -&gt; bool:\n        \"\"\"UPSERT the provided RRSet and wait for propagation; return True on success.\"\"\"\n        pass\n\n    @abstractmethod\n    def wait_for_dns_change_insync(self, change_id: str, record: Dict[str, Any]) -&gt; None:\n        \"\"\"Block until the change reaches INSYNC (or raise DNSError on failure/timeout).\"\"\"\n        pass\n\n    @abstractmethod\n    def verify_dns_change(self, record: Dict[str, Any]) -&gt; None:\n        \"\"\"Verify the UPSERT took effect; raise DNSError if verification fails.\"\"\"\n        pass\n\n    @abstractmethod\n    def clear_old_acme_txt(self, domain: str, zone_id: str) -&gt; bool:\n        \"\"\"Delete any stale `_acme-challenge` TXT records for the domain in zone; True on success.\"\"\"\n        pass\n\n    @abstractmethod\n    def build_domain_validation_record(self, tokens: List[str], domain: str, zone_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Build the TXT `_acme-challenge.&lt;domain&gt;` RRSet used to validate multiple tokens under the domain.\"\"\"\n        pass\n</code></pre>"},{"location":"components/plugins/#tlstool.dns.DNSBase-classes","title":"Classes","text":""},{"location":"components/plugins/#tlstool.dns.DNSBase.DNSError","title":"DNSError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for DNS-related failures.</p> Source code in <code>tlstool/dns/__init__.py</code> <pre><code>class DNSError(Exception):\n    \"\"\"Raised for DNS-related failures.\"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.dns.DNSBase-functions","title":"Functions","text":""},{"location":"components/plugins/#tlstool.dns.DNSBase.build_domain_validation_record","title":"build_domain_validation_record  <code>abstractmethod</code>","text":"<pre><code>build_domain_validation_record(tokens, domain, zone_id)\n</code></pre> <p>Build the TXT <code>_acme-challenge.&lt;domain&gt;</code> RRSet used to validate multiple tokens under the domain.</p> Source code in <code>tlstool/dns/__init__.py</code> <pre><code>@abstractmethod\ndef build_domain_validation_record(self, tokens: List[str], domain: str, zone_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Build the TXT `_acme-challenge.&lt;domain&gt;` RRSet used to validate multiple tokens under the domain.\"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.dns.DNSBase.change_dns","title":"change_dns  <code>abstractmethod</code>","text":"<pre><code>change_dns(record)\n</code></pre> <p>UPSERT the provided RRSet and wait for propagation; return True on success.</p> Source code in <code>tlstool/dns/__init__.py</code> <pre><code>@abstractmethod\ndef change_dns(self, record: Dict[str, Any]) -&gt; bool:\n    \"\"\"UPSERT the provided RRSet and wait for propagation; return True on success.\"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.dns.DNSBase.clear_old_acme_txt","title":"clear_old_acme_txt  <code>abstractmethod</code>","text":"<pre><code>clear_old_acme_txt(domain, zone_id)\n</code></pre> <p>Delete any stale <code>_acme-challenge</code> TXT records for the domain in zone; True on success.</p> Source code in <code>tlstool/dns/__init__.py</code> <pre><code>@abstractmethod\ndef clear_old_acme_txt(self, domain: str, zone_id: str) -&gt; bool:\n    \"\"\"Delete any stale `_acme-challenge` TXT records for the domain in zone; True on success.\"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.dns.DNSBase.find_acme_record","title":"find_acme_record  <code>abstractmethod</code>","text":"<pre><code>find_acme_record(zone_id)\n</code></pre> <p>Locate an existing <code>_acme-challenge</code> RRSet in the given hosted zone, if any.</p> Source code in <code>tlstool/dns/__init__.py</code> <pre><code>@abstractmethod\ndef find_acme_record(self, zone_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Locate an existing `_acme-challenge` RRSet in the given hosted zone, if any.\"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.dns.DNSBase.get_dns_client","title":"get_dns_client  <code>abstractmethod</code>","text":"<pre><code>get_dns_client()\n</code></pre> <p>Return the underlying DNS API client/session used by the plugin.</p> Source code in <code>tlstool/dns/__init__.py</code> <pre><code>@abstractmethod\ndef get_dns_client(self) -&gt; Any:\n    \"\"\"Return the underlying DNS API client/session used by the plugin.\"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.dns.DNSBase.verify_dns_change","title":"verify_dns_change  <code>abstractmethod</code>","text":"<pre><code>verify_dns_change(record)\n</code></pre> <p>Verify the UPSERT took effect; raise DNSError if verification fails.</p> Source code in <code>tlstool/dns/__init__.py</code> <pre><code>@abstractmethod\ndef verify_dns_change(self, record: Dict[str, Any]) -&gt; None:\n    \"\"\"Verify the UPSERT took effect; raise DNSError if verification fails.\"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.dns.DNSBase.wait_for_dns_change_insync","title":"wait_for_dns_change_insync  <code>abstractmethod</code>","text":"<pre><code>wait_for_dns_change_insync(change_id, record)\n</code></pre> <p>Block until the change reaches INSYNC (or raise DNSError on failure/timeout).</p> Source code in <code>tlstool/dns/__init__.py</code> <pre><code>@abstractmethod\ndef wait_for_dns_change_insync(self, change_id: str, record: Dict[str, Any]) -&gt; None:\n    \"\"\"Block until the change reaches INSYNC (or raise DNSError on failure/timeout).\"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#secrets","title":"Secrets","text":""},{"location":"components/plugins/#tlstool.secrets","title":"tlstool.secrets","text":""},{"location":"components/plugins/#tlstool.secrets-classes","title":"Classes","text":""},{"location":"components/plugins/#tlstool.secrets.SecretsBase","title":"SecretsBase","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for secrets management plugins.</p> Source code in <code>tlstool/secrets/__init__.py</code> <pre><code>class SecretsBase(ABC):\n    \"\"\"Abstract base class for secrets management plugins.\"\"\"\n\n    class SecretsError(Exception):\n        \"\"\"Raised for DNS-related failures.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_secrets_client(self) -&gt; object:\n        \"\"\"Return an authenticated client for the secrets backend.\n\n        Implementations should initialize and authenticate a provider-specific client\n        (e.g., AWS Secrets Manager) using application settings/environment.\n\n        Returns:\n            object: An SDK client/handle ready for secret operations.\n\n        Raises:\n            SecretsError: If the client cannot be created or authenticated.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_secret_value(self) -&gt; Union[dict, bool]:\n        \"\"\"Retrieve and return a secret value from the backing store.\n\n        Implementations should fetch the configured secret (e.g., an account key or\n        PEM blob) and return a decoded structure on success.\n\n        Returns:\n            dict | bool: Parsed/decoded secret content on success; False on failure.\n\n        Raises:\n            SecretsError: If the secret cannot be retrieved or decoded.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def store_pem_secret(self, domain: str, pem: str, tags: list[dict]) -&gt; str:\n        \"\"\"Create or update a PEM secret for a domain and return its identifier.\n\n        Implementations should upsert the secret at a deterministic path/key derived\n        from the domain and PEM label, applying any provided resource tags.\n\n        Args:\n            domain (str): Domain the PEM material belongs to.\n            pem (str): PEM content (or a structured object containing it).\n            tags (list[dict]): Provider-specific tag metadata to apply.\n\n        Returns:\n            str: Provider identifier for the stored secret (e.g., ARN).\n\n        Raises:\n            SecretsError: If storage fails.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def create_secret(self, domain: str, pem: str, tags: list[dict]) -&gt; Optional[str]:\n        \"\"\"Create a new secret when it does not already exist.\n\n        Implementations should create the secret with the provided content and tags\n        and return the provider-specific identifier.\n\n        Args:\n            domain (str): Domain the PEM material belongs to.\n            pem (str): PEM content (or a structured object containing it).\n            tags (list[dict]): Provider-specific tag metadata to apply.\n\n        Returns:\n            str | None: Identifier for the newly created secret, or None on failure.\n\n        Raises:\n            SecretsError: If creation fails.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"components/plugins/#tlstool.secrets.SecretsBase-classes","title":"Classes","text":""},{"location":"components/plugins/#tlstool.secrets.SecretsBase.SecretsError","title":"SecretsError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for DNS-related failures.</p> Source code in <code>tlstool/secrets/__init__.py</code> <pre><code>class SecretsError(Exception):\n    \"\"\"Raised for DNS-related failures.\"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.secrets.SecretsBase-functions","title":"Functions","text":""},{"location":"components/plugins/#tlstool.secrets.SecretsBase.create_secret","title":"create_secret  <code>abstractmethod</code>","text":"<pre><code>create_secret(domain, pem, tags)\n</code></pre> <p>Create a new secret when it does not already exist.</p> <p>Implementations should create the secret with the provided content and tags and return the provider-specific identifier.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain the PEM material belongs to.</p> required <code>pem</code> <code>str</code> <p>PEM content (or a structured object containing it).</p> required <code>tags</code> <code>list[dict]</code> <p>Provider-specific tag metadata to apply.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>str | None: Identifier for the newly created secret, or None on failure.</p> <p>Raises:</p> Type Description <code>SecretsError</code> <p>If creation fails.</p> Source code in <code>tlstool/secrets/__init__.py</code> <pre><code>@abstractmethod\ndef create_secret(self, domain: str, pem: str, tags: list[dict]) -&gt; Optional[str]:\n    \"\"\"Create a new secret when it does not already exist.\n\n    Implementations should create the secret with the provided content and tags\n    and return the provider-specific identifier.\n\n    Args:\n        domain (str): Domain the PEM material belongs to.\n        pem (str): PEM content (or a structured object containing it).\n        tags (list[dict]): Provider-specific tag metadata to apply.\n\n    Returns:\n        str | None: Identifier for the newly created secret, or None on failure.\n\n    Raises:\n        SecretsError: If creation fails.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.secrets.SecretsBase.get_secret_value","title":"get_secret_value  <code>abstractmethod</code>","text":"<pre><code>get_secret_value()\n</code></pre> <p>Retrieve and return a secret value from the backing store.</p> <p>Implementations should fetch the configured secret (e.g., an account key or PEM blob) and return a decoded structure on success.</p> <p>Returns:</p> Type Description <code>Union[dict, bool]</code> <p>dict | bool: Parsed/decoded secret content on success; False on failure.</p> <p>Raises:</p> Type Description <code>SecretsError</code> <p>If the secret cannot be retrieved or decoded.</p> Source code in <code>tlstool/secrets/__init__.py</code> <pre><code>@abstractmethod\ndef get_secret_value(self) -&gt; Union[dict, bool]:\n    \"\"\"Retrieve and return a secret value from the backing store.\n\n    Implementations should fetch the configured secret (e.g., an account key or\n    PEM blob) and return a decoded structure on success.\n\n    Returns:\n        dict | bool: Parsed/decoded secret content on success; False on failure.\n\n    Raises:\n        SecretsError: If the secret cannot be retrieved or decoded.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.secrets.SecretsBase.get_secrets_client","title":"get_secrets_client  <code>abstractmethod</code>","text":"<pre><code>get_secrets_client()\n</code></pre> <p>Return an authenticated client for the secrets backend.</p> <p>Implementations should initialize and authenticate a provider-specific client (e.g., AWS Secrets Manager) using application settings/environment.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>An SDK client/handle ready for secret operations.</p> <p>Raises:</p> Type Description <code>SecretsError</code> <p>If the client cannot be created or authenticated.</p> Source code in <code>tlstool/secrets/__init__.py</code> <pre><code>@abstractmethod\ndef get_secrets_client(self) -&gt; object:\n    \"\"\"Return an authenticated client for the secrets backend.\n\n    Implementations should initialize and authenticate a provider-specific client\n    (e.g., AWS Secrets Manager) using application settings/environment.\n\n    Returns:\n        object: An SDK client/handle ready for secret operations.\n\n    Raises:\n        SecretsError: If the client cannot be created or authenticated.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"components/plugins/#tlstool.secrets.SecretsBase.store_pem_secret","title":"store_pem_secret  <code>abstractmethod</code>","text":"<pre><code>store_pem_secret(domain, pem, tags)\n</code></pre> <p>Create or update a PEM secret for a domain and return its identifier.</p> <p>Implementations should upsert the secret at a deterministic path/key derived from the domain and PEM label, applying any provided resource tags.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain the PEM material belongs to.</p> required <code>pem</code> <code>str</code> <p>PEM content (or a structured object containing it).</p> required <code>tags</code> <code>list[dict]</code> <p>Provider-specific tag metadata to apply.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Provider identifier for the stored secret (e.g., ARN).</p> <p>Raises:</p> Type Description <code>SecretsError</code> <p>If storage fails.</p> Source code in <code>tlstool/secrets/__init__.py</code> <pre><code>@abstractmethod\ndef store_pem_secret(self, domain: str, pem: str, tags: list[dict]) -&gt; str:\n    \"\"\"Create or update a PEM secret for a domain and return its identifier.\n\n    Implementations should upsert the secret at a deterministic path/key derived\n    from the domain and PEM label, applying any provided resource tags.\n\n    Args:\n        domain (str): Domain the PEM material belongs to.\n        pem (str): PEM content (or a structured object containing it).\n        tags (list[dict]): Provider-specific tag metadata to apply.\n\n    Returns:\n        str: Provider identifier for the stored secret (e.g., ARN).\n\n    Raises:\n        SecretsError: If storage fails.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"components/storage/","title":"Storage Reference","text":""},{"location":"components/storage/#tlstool.storage","title":"tlstool.storage","text":""},{"location":"components/storage/#tlstool.storage-classes","title":"Classes","text":""},{"location":"components/storage/#tlstool.storage.StorageManager","title":"StorageManager","text":"Source code in <code>tlstool/storage.py</code> <pre><code>class StorageManager:\n\n    def __init__(self, secrets_plugin: SecretsBase):\n        \"\"\"Initialize the storage manager with secrets and Fastly configuration.\n\n        Stores the provided secrets plugin and loads Fastly configuration values\n        from application settings for use in certificate upload and retrieval.\n\n        Args:\n            secrets_plugin (SecretsBase): Secrets management plugin used to read\n                certificate material (PEMs) and related identifiers.\n\n        Returns:\n            None\n        \"\"\"\n        self.secrets = secrets_plugin \n        self.api_token = settings.FASTLY_API_TOKEN\n        self.fastly_tls_configuration_id = settings.FASTLY_TLS_CONFIGURATION_ID\n\n    def load_certificate(self, domain, certificate_ids):\n        \"\"\"Upload certificate materials to Fastly and return upload results.\n\n        Retrieves PEM materials using the provided identifiers, creates a private key\n        in Fastly, then creates a certificate in Fastly referencing the uploaded key.\n        If any step fails, an error string is returned; otherwise a result object is\n        returned containing both upload responses.\n\n        Args:\n            domain (str): The fully qualified domain name associated with the\n                certificate.\n            certificate_ids (Any): Identifiers required to retrieve PEM materials\n                from the secrets backend (implementation-specific; typically ARNs or\n                similar handles).\n\n        Returns:\n            dict | str: On success, a dict with:\n                {\n                    'pkey': &lt;private key upload response&gt;,\n                    'cert': &lt;certificate upload response&gt;\n                }\n                On failure, a string describing the error.\n        \"\"\"\n        private_key, secret_values = self._retrieve_pems(certificate_ids)\n        if private_key is None:\n            return secret_values  # This will be an error message string\n\n        pkey_upload = self._create_pkey_record(domain, private_key)\n        if 'Error' in str(pkey_upload):\n            logger.info(f\"Error on private key upload to Fastly: {str(pkey_upload)}\")\n            return str(pkey_upload)\n        else:\n            logger.info(\"Private key uploaded to Fastly\")\n\n        cert_upload = self._create_cert_record(domain, secret_values)\n        if 'Error' in str(cert_upload):\n            logger.info(f\"Error on certificate upload to Fastly: {str(cert_upload)}\")\n            return str(cert_upload)\n        else:\n            logger.info(\"Certificate uploaded to Fastly\")\n\n        upload_obj = {'pkey': pkey_upload, 'cert': cert_upload}\n        return upload_obj\n\n    def _retrieve_pems(self, certificate_ids):\n        \"\"\"Retrieve PEM materials from secrets storage using provided identifiers.\n\n        Parses the given identifiers to locate the private key and full-chain\n        certificate entries, fetches their values from the secrets backend, and\n        returns a tuple of the private key and a dict containing the certificate\n        and intermediate bundle blobs. On retrieval failure, returns `(None,\n        &lt;error_string&gt;)`.\n\n        Args:\n            certificate_ids (list[dict]): Iterable of items produced by the\n                certificate request flow, each with:\n                - 'key' (str): Logical name; expected values include\n                  'private_key' and 'fullchain'.\n                - 'value' (str): Backend-specific identifier for the secret\n                  (e.g., an ARN or secret name).\n\n        Returns:\n            tuple[str | None, dict | str]:\n                - On success: `(private_key, {'cert_blob': str, 'intermediates_blob': str})`.\n                - On error: `(None, 'Error message string')`.\n        \"\"\"\n        secret_id = ''\n        pkey_id = ''\n        for c in certificate_ids:\n            if c['key'] == 'fullchain':\n                secret_id = c['value']\n            if c['key'] == 'private_key':\n                pkey_id = c['value']\n\n        private_key = ''\n        if pkey_id:\n            try:\n                private_key = self.secrets.get_secret_value(pkey_id)\n            except Exception as e:\n                error = f\"Error retrieving certificate string from secrets storage: {e}\"\n                logger.exception(error)\n                return None, error\n\n        secret_values = {}\n        if secret_id:\n            try:\n                secret_str = self.secrets.get_secret_value(secret_id)\n                secret_values['cert_blob'] = secret_str.split('\\n\\n')[0]\n                intermediates = ('\\n\\n').join(secret_str.split('\\n\\n')[1:3])\n                if intermediates.endswith('\\n'):\n                    intermediates = intermediates[:-(len('\\n'))]\n                secret_values['intermediates_blob'] = intermediates\n            except Exception as e:\n                error = f\"Error retrieving certificate string from secrets storage: {e}\"\n                logger.exception(error)\n                return None, error\n\n        return private_key, secret_values\n\n    def _create_pkey_record(self, domain, pkey):\n        \"\"\"Create a TLS private key record in Fastly.\n\n        Authenticates with the Fastly API using the configured token and creates a\n        new TLS private key resource associated with the given domain. If the key\n        already exists or an API error occurs, returns an error string.\n\n        Args:\n            domain (str): The fully qualified domain name the key is associated with.\n            pkey (str): PEM-encoded private key content.\n\n        Returns:\n            Any | str: The Fastly API response object on success; otherwise an error\n                string describing the failure.\n        \"\"\"\n        configuration = fastly.Configuration()\n        configuration.api_token = self.api_token\n\n        with fastly.ApiClient(configuration) as api_client:\n            api_instance = tls_private_keys_api.TlsPrivateKeysApi(api_client)\n            options = {\n                'tls_private_key': {\n                    'data': {\n                        'type': 'tls_private_key',\n                        'attributes': {\n                            'key': pkey,\n                            'name': f'{domain} private key',\n                        },\n                    },\n                },\n            }\n\n            try:\n                api_response = api_instance.create_tls_key(**options)\n                logger.info(f\"Fastly API Response on create key: {api_response}\")\n            except fastly.ApiException as e:\n                if \"Key already exists\" in str(e):\n                    err = f\"Error: Private key already exists: {e}\"\n                    logger.exception(err)\n                    return err\n                else:\n                    err = f\"Error: Exception when calling TlsPrivateKeysApi-&gt;create_tls_key: {e}\"\n                    logger.exception(err)\n                    return err\n\n        return api_response\n\n    def _create_cert_record(self, domain, secret_values):\n        \"\"\"Create a TLS certificate record in Fastly via the bulk certificates API.\n\n        Builds a bulk certificate payload using the provided certificate and\n        intermediates blobs, associates it with the configured TLS configuration,\n        and POSTs it to Fastly. Returns the parsed JSON response on success or an\n        error string on failure.\n\n        Args:\n            domain (str): The fully qualified domain name the certificate pertains to.\n            secret_values (dict): Dictionary containing:\n                - 'cert_blob' (str): PEM-encoded end-entity certificate (no key).\n                - 'intermediates_blob' (str): PEM-encoded intermediate chain.\n\n        Returns:\n            dict | str: Parsed JSON response from Fastly on success; otherwise an\n                error string describing the failure.\n        \"\"\"\n        url = \"https://api.fastly.com/tls/bulk/certificates\"\n\n        options = {\"data\": {\n            \"type\": \"tls_bulk_certificate\",\n            \"attributes\": {\"allow_untrusted_root\": True, \"cert_blob\": secret_values['cert_blob']+\"\\n\", \"intermediates_blob\": secret_values['intermediates_blob']+\"\\n\"},\n            \"relationships\": {\"tls_configurations\": {\"data\": [{\"type\": \"tls_configuration\", \"id\": self.fastly_tls_configuration_id}]}}\n        }}\n        payload = json.dumps(options)\n\n        headers = {\n            'Host': 'api.fastly.com',\n            'Content-Type': 'application/vnd.api+json',\n            'Accept': 'application/vnd.api+json',\n            'Fastly-Key': self.api_token\n        }\n        try:\n            response = requests.request(\"POST\", url, headers=headers, data=payload)\n            api_response = response.json()\n            logger.info(f\"Fastly API Response on create cert: {api_response}\")\n        except Exception as e:\n            err = f\"Error: Exception when posting cert object: {e}\"\n            logger.exception(err)\n            return err\n\n        return api_response\n</code></pre>"},{"location":"components/storage/#tlstool.storage.StorageManager-functions","title":"Functions","text":""},{"location":"components/storage/#tlstool.storage.StorageManager.load_certificate","title":"load_certificate","text":"<pre><code>load_certificate(domain, certificate_ids)\n</code></pre> <p>Upload certificate materials to Fastly and return upload results.</p> <p>Retrieves PEM materials using the provided identifiers, creates a private key in Fastly, then creates a certificate in Fastly referencing the uploaded key. If any step fails, an error string is returned; otherwise a result object is returned containing both upload responses.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The fully qualified domain name associated with the certificate.</p> required <code>certificate_ids</code> <code>Any</code> <p>Identifiers required to retrieve PEM materials from the secrets backend (implementation-specific; typically ARNs or similar handles).</p> required <p>Returns:</p> Type Description <p>dict | str: On success, a dict with: {     'pkey': ,     'cert':  } On failure, a string describing the error. Source code in <code>tlstool/storage.py</code> <pre><code>def load_certificate(self, domain, certificate_ids):\n    \"\"\"Upload certificate materials to Fastly and return upload results.\n\n    Retrieves PEM materials using the provided identifiers, creates a private key\n    in Fastly, then creates a certificate in Fastly referencing the uploaded key.\n    If any step fails, an error string is returned; otherwise a result object is\n    returned containing both upload responses.\n\n    Args:\n        domain (str): The fully qualified domain name associated with the\n            certificate.\n        certificate_ids (Any): Identifiers required to retrieve PEM materials\n            from the secrets backend (implementation-specific; typically ARNs or\n            similar handles).\n\n    Returns:\n        dict | str: On success, a dict with:\n            {\n                'pkey': &lt;private key upload response&gt;,\n                'cert': &lt;certificate upload response&gt;\n            }\n            On failure, a string describing the error.\n    \"\"\"\n    private_key, secret_values = self._retrieve_pems(certificate_ids)\n    if private_key is None:\n        return secret_values  # This will be an error message string\n\n    pkey_upload = self._create_pkey_record(domain, private_key)\n    if 'Error' in str(pkey_upload):\n        logger.info(f\"Error on private key upload to Fastly: {str(pkey_upload)}\")\n        return str(pkey_upload)\n    else:\n        logger.info(\"Private key uploaded to Fastly\")\n\n    cert_upload = self._create_cert_record(domain, secret_values)\n    if 'Error' in str(cert_upload):\n        logger.info(f\"Error on certificate upload to Fastly: {str(cert_upload)}\")\n        return str(cert_upload)\n    else:\n        logger.info(\"Certificate uploaded to Fastly\")\n\n    upload_obj = {'pkey': pkey_upload, 'cert': cert_upload}\n    return upload_obj\n</code></pre>"}]}